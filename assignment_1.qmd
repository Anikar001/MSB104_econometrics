---
title: "Assignment 1: Data and Descriptive"
author: "Anine Therese Karlsen & Mona Lisa Jones"
format: pdf
abstract: "This assignment aims to acquire, process, and analyze sub-national GDP and population data for a subset of European countries. Calculate GDP per capita and explore regional inequity using various descriptive statistics and visualizations."
editor: visual
bibliography: [Econometrics.bib]
page-layout: full
number-sections: true
papersize: a4
csl: apa.csl
---

```{r}
#| label: setup
#| output: false
#| echo: false

library(tidyverse)
library(tinytex)
library(ggplot2)
library(readxl)
library(magrittr)
library(vtable)
library(lubridate)
library(dineq)
library(huxtable)
library(sandwich)
library(lmtest)
```

# Introduction

While national GDP and GDP per capita are vital indicators of a country's aggregate economic health, they do not shed light on how wealth or income is distributed among its residents. A high national GDP can, paradoxically, coexist with pockets of regional deprivation [@lessmann2017].

The truth of this statement becomes more evident when taking a closer look in to into sub-national data. Regional wealth disparities are of prime concern, especially when crafting policies for equitable growth [@lessmann2017]. A country's macro-level prosperity does not automatically guarantee that all its regions partake equally in this wealth. By studying smaller regions within a country, it is possible to get a more nuanced narrative about the state of regional economic disparities [@lessmann2017].

This assignment is anchored in this very premise. It seeks to acquire, process, and analyse sub-national GDP and population data for a selected subset of European countries, namely France, Denmark, Hungary, Portugal, and Slovakia, spanning the period from 2000 to 2020. The overarching aim is to calculate GDP per capita for these regions and delve into the intricacies of regional inequity. This exploration will be underpinned by various descriptive statistics, visualizations, and analytical techniques to paint a comprehensive picture of regional economic landscapes.

Using time series data observing the GDP per capita and GINI trends across regions and over time, we can discern whether certain areas are ahead or behind in economic performance.

# Literature review

"In recent decades, the regional distribution of incomes within countries has attracted considerable interest among academics and policy makers." [@lessmann2017]

Slovakia, experienced significant economic growth. Their GDP per capita grew faster than the older EU member states, albeit from a lower starting point, leading to a convergence [@fullart].

The global financial crisis and subsequent European debt crisis had significant impacts on European economies. GDP per capita declined in several countries, particularly those hit hardest by the crisis, such as Greece, Spain, and Portugal. Some regions took many years to recover to pre-crisis levels, while others, especially in Northern Europe, recovered more quickly [@lewis].

Major metropolitan areas, like Paris in France, London in the UK, and Berlin in Germany, often grew faster than other regions in their respective countries, leading to increasing spatial disparities [@kiuru2019].

Denmark maintained relatively high levels of GDP per capita throughout this period, benefiting from a diversified economy, strong institutions, and a high degree of economic openness. It did face challenges during the 2008 economic crisis but recovered relatively quickly [@dynamics].

Slovenia, which joined the EU in 2004, showed growth in GDP per capita, though it too was affected by the global economic downturn in 2008. However, it managed to recover in the subsequent years [@fullart].

Regional disparities persisted, with the Île-de-France region (which includes Paris) significantly outperforming other regions in terms of GDP per capita. The gap between urban and rural areas also remained a topic of discussion [@regional].

Towards the end of this period, in early 2020, the COVID-19 pandemic posed a new set of challenges for European economies, causing significant contractions in GDP per capita across many regions [@regional].

# Part A: Sub-national GDP and GDP per Capita

## Data Acquisition and datasets

The first thing we did in this assignment was to acquire our data. Trough Eurostat, we could download the datasets nama_10r_3gdp and demo_r_pjanggr3 as csv files, as well as filter the data by our preferences before downloading it. As per the assignment, we filtered the dataset by choosing the years 2000 to 2020. Furthermore, we selected the NUTS 3 region for the nations we were given, which were Portugal, France, Hungary, Slovakia and Denmark. Finally, we specified the data to be in million Euro.

### GDP (nama_10r_3gdp)

The nama_10r_3gdp dataset from Eurostat provides insights into GDP at regional level using the NUTS classification system. It furnishes GDP values in both current prices and adjusted for inflation, with some figures given in purchasing power standards (PPS) to account for price level differences between countries. The data is often structured by year and region @eurostat2023.

The GDP at market prices represents the final result of production activities of resident producer units within a region or nation. It is calculated as the sum of the gross value added across various institutional sectors or industries, augmented by taxes and reduced by subsidies on products (which are not allocated to specific sectors or industries). This also balances out in the total economy production account. In terms of methodology, while national accounts compile GDP from the expenditure side, regional accounts don't adopt this approach due to the complexities of accurately mapping inter-regional flows of goods and services.

The different measures for the regional GDP are absolute figures in € and Purchasing Power Standards (PPS), figures per inhabitant and relative data compared to the EU Member States average @eurostat2023c.

### Population (demo_r_pjanggr3)

Using the NUTS categorization once more, Eurostat's demo_r_pjanggr3 records annual population changes at the regional level. This dataset includes information on births, deaths, net migration, and may also include demographic information on age and gender. It's also often displayed in a year-by-region format, and the data usually spans in yearly intervals @eurostat2023a.

Eurostat's primary source for yearly demographic data at the regional level stems from the Unified Demography (Unidemo) project. The project covers 37 countries and is the central repository for demographic and migration-related data. Specific metrics gathered under UNIDEMO encompass population counts at the close of the calendar year and events such as births and deaths occurring within that year. Additionally, data on marriages, divorces, and migration flows are recorded.

For the purpose of this research, the demographic data references the NUTS 2016 classification, which provides a detailed breakdown of the European Union's territory @eurostat2021.

### NUTS classification

The Nomenclature of Territorial Units for Statistics (NUTS) offers a stratified system to segment the economic territory of the EU (including the UK) to facilitate the consistent collection and harmonization of regional statistics across Europe. The NUTS regions range from NUTS 0 Country level to NUTS 3 small units such as municipalities level.  

```{r}
#| echo: false
#| output: false

# This section of the code is dedicated to adding data to RStudio. We will import the datasets into the RStudio environment for further analysis, manipulation, and visualization using R.

# Data for population
pop_data <- read_csv("Raw_data/demo.gz")

# Data for GDP
gdp_data <- read_csv("Raw_data/nama.gz")
```

```{r}
#| echo: false
#| output: false
# Renaming and selecting the variables we want to keep
# We're doing this in order to make the datasets more clean and easy to read

gdp_data_01 <- gdp_data |>
  select(geo, year = TIME_PERIOD, GDP = OBS_VALUE)

pop_data_01 <- pop_data |>
  select(geo, year = TIME_PERIOD, population = OBS_VALUE)
```

## GDP per Capita Calculation

The formula for calculating GDP per Capita is as follows:

$y_i=GDP_i/population_i$

```{r}
#| echo: false
#| output: false

# Merging the datasets pop_data and gdp_data into one dataset by joining the variables "geo" and "year". 

merged_data <- left_join(pop_data_01, gdp_data_01, join_by(geo, year))

# Select Only NUTS 3 Regions
# Filter for specific countries, this will be useful when we will find the GDP per capita for the countries seperately

merged_data <- merged_data |>
  filter(
    startsWith(as.character(geo), "PT") | 
    startsWith(as.character(geo), "FR") | 
    startsWith(as.character(geo), "HU") |
    startsWith(as.character(geo), "SK") | 
    startsWith(as.character(geo), "DK")
  ) %>%
  
# Filter rows where 'geo' column has more than 4 characters to select only NUTS3 regions
  filter(nchar(as.character(geo)) > 4) %>%
  
# Rename 'geo' column to 'id_nuts3'
  rename(id_nuts3 = geo)
```

```{r}
#| echo: false
#| output: false

# Calculating GDP per Capita

GDP_per_capita <- merged_data |>
  mutate(
    GDP_per_capita = round(100*GDP/population, digits = 2)
  )

# we use *100 in order to get the gdp per capita as a percentage, and digits = 2 to limit it down to two decimals
```

After calculating the GDP per capita for all NUTS 3 regions in our assigned countries, we can see that there is a large spread between the figures for the various regions. In this assignement we want to look at regional inequity; in order to do this in a valuable way we have to divide between the different countries. By doing this, we can gain important insights on regional differences that we can utilize, for instance, to discuss national policy on equity and sustainable economic development in regions.

### Descriptive statistics

In this part we will report and interpret different types of essential descriptive statistics. Measuring regional income inequality is challenging due to heterogeneity of regions. The number of regions in our data set varies largely in size and population. Since the focus of this paper is purely growth and changes in inequities over time, the variations of size and population density becomes a minor issue because the country-level territorial heterogeneity is fixed.

"Interest in income inequality has led to the development of several ways of measuring it. Two types of measures are of interest in this paper----static and dynamic. *Static measures* provide a snapshot of these inequalities at a point of time whereas the dynamic *measures capture historical trends.*" (læreboken)

In this part, we'll look at GDP per capita for our assigned countries on a NUTS 3 level. In addition, we'll use different kinds of descriptive statistics in order to further 0,37, is analyse this data. In this analysis, we'll use @wooldridge2020 for help.

By using figures, we can visualize the GDP per capita, and look at how it varies among the different regions. In these figures, a line represent one NUTS 3 region.

**Mean**

Calculate the mean to provide a representative value for a dataset, facilitating understanding of its central tendency and serving as a benchmark against which deviations and anomalies can be assessed, in later steps when building and interpreting regression models.

**MMR**

A comparison of the GRDP (gross regional domestic product) per capita of the region with the highest income to the region with the lowest income (minimum per capita GRDP) provides a measure of the range of these disparities. If this measure is small (close to 1), then it would mean that the different regions have relatively equal incomes. If this measure is large, then the interpretation is more problematic, as it does not tell us if the high ratio is due to substantial variation in the distribution of per capita GDRPs or the presence of outliers. Nevertheless, maximum to minimum ratio (MMR) provides a quick, easy to comprehend, and politically powerful measure of regional income inequality.

**Standard diviation (SD)**

Calculating SD to quantify the dispersion or variability of a data set around its mean. Helping us assess the degree of uncertainty, variability, or risk associated with an economic variable or parameter, which is crucial for understanding the reliability of estimations and predictions [@wooldridge2020].

**Median**

The median serves as a robust measure of central tendency, especially when a dataset may have outliers or is skewed. Unlike the mean, the median is not influenced by extreme values and, thus, can provide a clearer picture of the "typical" value in situations where the data distribution is not symmetrical [@wooldridge2020].

### Portugal

```{r}
#| echo: false
#| output: false

# Making a dataset that only contains data from Portugal
# Use the na.omit function in order to remove NA values, cant make ggplot with NA values. 

Portugal_data <- GDP_per_capita |>
  filter(grepl("PT", id_nuts3)) |>
  na.omit(Portugal_data)
```

```{r}
#| echo: false

# Making a figure using ggplot that shows us variations of GDP per capita across the different NUTS 3 regions in Portugal. 

Portugal_data_plot <- ggplot(Portugal_data, aes(x = year, y = GDP_per_capita, color = id_nuts3)) +
  geom_line() +
  labs(title="Figure 1: GDP per Capita for Portugal", 
       x="Year",
       y="GDP per Capita") +
  theme(legend.position="none")

# Print out the figure

print(Portugal_data_plot)
```

```{r}
#| echo: false

# Calculate summary statistics for Portugal, chosing only GDP per capita 
summary_stats_portugal <- sapply(Portugal_data["GDP_per_capita"], function(x) c(
  mean = mean(x),
  median = median(x),
  std_dev = sd(x),
  minimum = min(x),
  maximum = max(x)
))

# Print the summary statistics
print(summary_stats_portugal)
```

By looking at figure for Portugal, we can see that the GDP per capita in Portugal's regions appears to be fairly consistent. There is however some regional variability. We can see that the regions around the big cities like Lisbon have a higher GDP per capita compared to some more rural areas. Since Lisbon is the capital of Portugal, there is probably a higher concentration of industries, making it a economic center (which again makes the GDP per capita higher).

To continue, we can see that the mean is a little higher that the median, something that might indicate that regions like Lisbon are pulling up the average. If we compare the standard derivation for Portugal with the other countries, we'll see that is fairly low in comparison. This might mean that there is not a lot of variability between the GDP per capita across different regions in Portugal. The gap between minimum and maximum is also low compared to other countries, something that'll also show us that the economic disparity in Portugal might not be as high as it is in other countries.

### France

```{r}
#| echo: false
#| output: false

# Making a dataset that only contains data from France

France_data <- GDP_per_capita |>
  filter(grepl("FR", id_nuts3)) |>
  na.omit(France_data)
```

```{r}
#| echo: false

# Making a figure using ggplot that shows us variations of GDP per capita across the different NUTS 3 regions in France. 

France_data_plot <- ggplot(France_data, aes(x = year, y = GDP_per_capita, color = id_nuts3)) +
  geom_line() +
  labs(title="Figure 1: GDP per Capita for France", 
       x="Year",
       y="GDP per Capita") +
  theme(legend.position="none")

print(France_data_plot)
```

```{r}
#| echo: false

# Calculate summary statistics for France, chosing only GDP per capita 
summary_stats_france <- sapply(France_data["GDP_per_capita"], function(x) c(
  mean = mean(x),
  median = median(x),
  std_dev = sd(x),
  minimum = min(x),
  maximum = max(x)
))

# Print the summary statistics
print(summary_stats_france)
```

When looking at the figure for France, we can right away see that there are some regions that have a much higher GDP per capita compared to the other regions. The region that has the highest GDP per capita for all years is the île-de-France region, one that also includes Paris. This significant difference between the regions with the highest GDP per capita and the lowest, shows us that there is a high concentration of economic activity and wealth in a few urban regions. Similar to Portugal, we can also again see that there is a difference between urban and rural regions.

Just as in Portugal, there is also a higher mean in France as well. Something that is different from the data in France compared to Portugal, is that the standard derivation is higher, and the difference between minimum and maximum is large. This strengthens what we have look at earlier in the figure, with some regions having a high concentration of wealth.

### Hungary

```{r}
#| echo: false
#| output: false

# Making a dataset that only contains data from Hungary

Hungary_data <- GDP_per_capita |>
  filter(grepl("HU", id_nuts3)) |>
  na.omit(Hungary_data)
```

```{r}
#| echo: false

# Making a figure using ggplot that shows us variations of GDP per capita across the different NUTS 3 regions in Hungary. 

Hungary_data_plot <- ggplot(Hungary_data, aes(x = year, y = GDP_per_capita, color = id_nuts3)) +
  geom_line() +
  labs(title="Figure 1: GDP per Capita for Hungary", 
       x="Year",
       y="GDP per Capita") +
  theme(legend.position="none")

print(Hungary_data_plot)
```

```{r}
#| echo: false

# Calculate summary statistics for Hungary, chosing only GDP per capita 
summary_stats_hungary <- sapply(Hungary_data["GDP_per_capita"], function(x) c(
  mean = mean(x),
  median = median(x),
  std_dev = sd(x),
  minimum = min(x),
  maximum = max(x)
))

# Print the summary statistics
print(summary_stats_hungary)
```

In Hungary, most of the regions have similar GDP per Capita. One region that sticks out by having a higher value, is the region of Budapest, Hungary's biggest city.

We have here as well an mean that is larger than the median, high standard derivation, and a large gap between minimum and maximum.

### Slovakia

```{r}
#| echo: false
#| output: false

# Making a dataset that only contains data from Slovakia

Slovakia_data <- GDP_per_capita |>
  filter(grepl("SK", id_nuts3)) |>
  na.omit(Slovakia_data)
```

```{r}
#| echo: false

# Making a figure using ggplot that shows us variations of GDP per capita across the different NUTS 3 regions in Slovakia. 

Slovakia_data_plot <- ggplot(Slovakia_data, aes(x = year, y = GDP_per_capita, color = id_nuts3)) +
  geom_line() +
  labs(title="Figure 1: GDP per Capita for Slovakia", 
       x="Year",
       y="GDP per Capita") +
  theme(legend.position="none")

print(Slovakia_data_plot)
```

```{r}
#| echo: false

# Calculate summary statistics for Slovakia, chosing only GDP per capita 
summary_stats_slovakia <- sapply(Slovakia_data["GDP_per_capita"], function(x) c(
  mean = mean(x),
  median = median(x),
  std_dev = sd(x),
  minimum = min(x),
  maximum = max(x)
))

# Print the summary statistics
print(summary_stats_slovakia)
```

In Slovakia as well, we have one region that has a much higher GDP per capita than the rest of the regions. This region is Bratislava, which is the biggest city and capital, something that might point to this city being the economic capital of Slovakia as well.

Slovakia has also a mean higher that the median, and a large gap between minimum and maximum. In addition, the standard derivation is pretty high, meaning that there is some regions (or one region in this case) that is far away from the rest of the regions when it comes to economic development.

### Denmark

```{r}
#| echo: false
#| output: false

# Making a dataset that only contains data from Denmark

Denmark_data <- GDP_per_capita |>
  filter(grepl("DK", id_nuts3)) |>
  na.omit(Denmark_data)
```

```{r}
#| echo: false

# Making a figure using ggplot that shows us variations of GDP per capita across the different NUTS 3 regions in Denmark. 

Denmark_data_plot <- ggplot(Denmark_data, aes(x = year, y = GDP_per_capita, color = id_nuts3)) +
  geom_line() +
  labs(title="Figure 1: GDP per Capita for Denmark", 
       x="Year",
       y="GDP per Capita") +
  theme(legend.position="none")

print(Denmark_data_plot)
```

```{r}
#| echo: false

# Calculate summary statistics for Denmark, chosing only GDP per capita 
summary_stats_denmark <- sapply(Denmark_data["GDP_per_capita"], function(x) c(
  mean = mean(x),
  median = median(x),
  std_dev = sd(x),
  minimum = min(x),
  maximum = max(x)
))

# Print the summary statistics
print(summary_stats_denmark)
```

Lastly, we have Denmark. We can see similar pattern here as well, with the capital Copenhagen being one of the regions with the highest GDP per capita.

We can also see the same as the previous countries, with the mean being higher than the median, which shows us that regions like Copenhagen might drag the mean up by being much larger than the rest of the regions.

# Part B: Regional Inequity

## Gini Coefficient Calculation

With the use of the NUTS3 GDP per capita data and this formula:

$GINW_j=\frac{1}{2 \bar{y_j}} \sum_{i}^{n_j}\sum_{l}^{n_j}\frac{p_i}{P_j} \frac{p_l}{P_j} |y_i-y_l|$

we will compute the population-weighted GDP Gini coefficient for each European NUTS2 region in our assigned countries.

The gini coefficient can help us measure inequality in a distribution, as is therefore a useful tool for us to use when we look at regional inequity. The closer the gini coefficient is to 1, the bigger the inequality is; a number closer to 0 equals equality. When looking at the gini coefficient for NUTS 2 regions, we also get a better overview over differences in income between different regions, and it also makes it easier to find the reasons as to why there is a difference between the regions @hasell2023.

```{r}
#| echo: false
#| output: false

# Before we can find the Gini coefficient for NUTS2 regions, we have to generate NUTS 2 and 0 identifiers

# Generate NUTS 2 and 0 Identifiers
main_data <- GDP_per_capita |> 
  mutate(
    id_nuts2 = substr(id_nuts3, 1, 4),
    id_nuts0 = substr(id_nuts3, 1, 2)
  ) 
```

```{r}
#| echo: false
#| output: false

# Calculating gini
gini <- main_data |>
  filter(population != 0) |>
  filter(population != "NA") |>
  filter(GDP_per_capita != 0) |>
  filter(GDP_per_capita != "NA") |>
  group_by(id_nuts2, year) |>
  mutate(gini_n2 = gini.wtd(GDP_per_capita, weights = population)) |>
  ungroup()


# Slice function to remove numbers that get repeated. 
gini_nuts_2 <- gini |>
  group_by(id_nuts2, year) |>
  slice(1) |>
  ungroup()

# Since some NUTS 2 and 3 regions are the same (like Copenhagen for example), some gini coefficients will be 0. We should remove them before doing further analysis and data presentation

# Filter data
gini_filtered <- gini_nuts_2 |>
  filter(gini_n2 != 0)
```

After calculating the gini coefficients, we can see that there are some similarities to the data we got from GDP per capita for NUTS 3 regions. In order to see these similarities better, as well as look for other important aspects that can be provided trough the calculations, we will visualize the data in three different ways.

```{r}
#| echo: false

# Creating a bar chart
ggplot(gini_filtered, aes(x = id_nuts2, y = gini_n2, fill = id_nuts0)) +
  geom_bar(stat = "identity") +
  ggtitle("Gini Coefficient by NUTS 2 Region") +
  xlab("NUTS 2 Region ID") +
  ylab("Gini Coefficient") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

...

```{r}
#| echo: false

# Creating a time-series plot
ggplot(gini_filtered, aes(x = year, y = gini_n2, color = id_nuts2)) +
  geom_line() +
  ggtitle("Time-series Plot of Gini Coefficient by NUTS 2 Region") +
  xlab("Year") +
  ylab("Gini Coefficient")
```

...

```{r}
#| echo: false

# Creating a box plot
ggplot(gini_filtered, aes(x = id_nuts0, y = GDP_per_capita)) +
  geom_boxplot() +
  ggtitle("Distribution of GDP per Capita by Country") +
  xlab("Country") +
  ylab("GDP per Capita")
```

... p. 116

## Discussion

# Assignment 2: Cross-sectional Estimates

## 2A: Growth and Inequity

### 1. Model Estimation

**Scale-Location Plot** is another way to check for homoscedasticity. The spread of the residuals should be roughly the same across all levels of the fitted values. If the spread increases or decreases with the fitted values, it suggests heteroscedasticity.

**Residuals vs. Leverage Plot** to identify influential observations that might unduly influence the regression. Points with high leverage or large residuals (outliers) can be identified. Cook's distance lines may be added to help identify points that have a large influence on the model.

$GINI = \beta_{0} + \beta_{1} \cdot \text{GDP per capita} + \epsilon$

Gini is the dependent variable (y), while GDP per capita is the independent variable (x).

```{r}
#| echo: false
#| output: false

# Making a dataframe that only contains observations from 2010, we're also filtering the data so that gini is bigger than 0. 

data2010 <- gini_nuts_2 |>
  filter(year == 2010, gini_n2 > 0)
```

```{r}
#| echo: false
#| fig-cap: Regression statistics of all countries for the year 2010

# Finding the natural logarithm of GDP per capita
data2010 <- data2010 |> 
  mutate(log_GDP_per_capita = log(GDP_per_capita))


# lm(y ~ x) y = gini, x = log of GDP per capita, estimation of linear regression model
lm <- lm(gini_n2 ~ log_GDP_per_capita, data = data2010)

# Save coefficients
b0_earn <- lm$coefficients[1]
b1_earn <- lm$coefficients[2]

# Regression statistics by using huxreg
huxreg(All = lm, 
       statistics = c("r.squared","adj.r.squared", "statistic", "p.value"))
```

```{r}
#| echo: false
#| output: false

# Summary
summary(lm)
```

Beta 0​ = 0.0551 (intercept)

Beta 1 = 0.0193 (slope coefficient)

```{r}
#| echo: false
#| fig-cap: Regression statistics of all countries seperately for the year 2010

# Estimation for each country seperately 
lmSK <- lm(gini_n2 ~ log_GDP_per_capita, subset(data2010, id_nuts0 == "SK"))
lmDK <- lm(gini_n2 ~ log_GDP_per_capita, subset(data2010, id_nuts0 == "DK"))
lmHU <- lm(gini_n2 ~ log_GDP_per_capita, subset(data2010, id_nuts0 == "HU"))
lmPT <- lm(gini_n2 ~ log_GDP_per_capita, subset(data2010, id_nuts0 == "PT"))
lmFR <- lm(gini_n2 ~ log_GDP_per_capita, subset(data2010, id_nuts0 == "FR"))

# Regression statistics
huxreg(SK = lmSK, 
       DK = lmDK, 
       HU = lmHU, 
       PT = lmPT, 
       FR = lmFR, 
       statistics = c("r.squared","adj.r.squared", "statistic", "p.value"))
```

```{r}
#| echo: false
#| output: false

# Summary
summary(lmSK)
summary(lmDK)
summary(lmPT)
summary(lmFR)
summary(lmHU)
```

### 2. Model Diagnostics

We'll now look at some of the numbers we got from the linear regression model (for all countries combined):

-   Coefficients:

    -   Intercept is 0.0551 (expected value of gini when GDP per capita is 0). Statistically significant (indicated by p-value).

    -   Estimated coefficient for GDP per capita is 0.0193, if the natural logarithm of GDP per capita increase by one, then the gini coefficient will increase by 0.0193. The p-value associated with the coefficent is however not statistically significant at 5% level.

-   Goodnes of fit:

    -   Multiple R-squared (0.08028) indicate that around 8% of the variability in the GINI coefficient is explained by the model. This is low, which can suggest that the model dosen't explain the variation in gini.

    -   Adjusted R-squared is even lower (0.05474), is therefore expected that the model dosen't really explain the variance in the dependent variable (gini).

-   Model significance:

    -   The F-statistic (3.142) indicate the significance of the regression model. We can see here, that with the p-value of 0.08474, the model isn't significant at a 5% level.

By looking at these numbers, we can see that the model may not reliably predict the gini coefficient. It also suggest that GDP per capita may not be a valid predictor of the gini coefficient.

We also examined our selected countries seperately in order to see how the reliability and validity of the model might vary between countries. However, since there are too few observations for most of the countries, it makes it hard to make a conclusion of the reliability. What we can see from this examination, is that the models for Denmark, Portugal and Slovakia are not statistically significant. France seem however to have significant coefficiants, and Hungary have a moderate R-squared (but lacks significance in the slope).

### 3. Visualization

```{r}
#| echo: false

# Making two plots, first one is a residuals vs fitted plot, while the other is a normal Q-Q residuals plot
plot(lm, which = 1:2) 
```

We've made two plots that can help us understand the relationship between GDP per capita and the Gini coefficient, and that together with the regression statistics can help with discussing if the classical OLS assumptions hold for the model. The first one is a plot that shows us residuals vs fitted values, which can help us check the homoscedasticity assumption of a linear regression model. The residuals should be randomly scattered around the horisontal 0 line, something that can inducate that the variances of the error terms are constant. In our plot, the residuals are in some extent randomly distributed, and there is also no clear pattern; this suggest that there is likely no significant issues with heteroscedasticity or non-linearity.

The other plot - normal Q-Q plot - is used to assess if the residuals of the linear model are normally distributed. In our plot, most of the points follow the line closely, suggesting that the residuals are normally distributed. There are however some outliers in the tails, that suggest some variation from normality.

...

In both of these plots, we can see that there are some outliers, these can affect the fit of the model. These outliers might come from regions that have a high GDP per capita compared to rest of the regions, like Paris in France that is a financial hub.

```{r}
#| echo: false
#| label: fig_scatterplot-all
#| cap-location: bottom
#| fig-cap: "Relationship Between GDP per Capita and Gini"

# Visualization of the relationship between GDP per capita and gini
ggplot(data2010, aes(x = log_GDP_per_capita, y = gini_n2)) +
  geom_point(aes(color = log_GDP_per_capita), size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(
    title = "Relationship Between GDP per Capita and Gini",
    x = "GDP per capita",
    y = "Gini",
    caption = "Red line indicates the fitted regression line"
  ) +
  theme_minimal()
```

In this plot we are visualizing the relationship between GDP per capita and gini by using a mix of the two previous plots. We can here as well, see extreme outliers.

## 2B: Exploring Other Determinants of Inequity

### 1. Data Acquistion

In order to conduct a Multiple Linear Regression model, we need to have some independent variables to use in the model and compare them with the dependent variable. The first variable, education, can explain income inequality, since it can influence income distribution in a region. If access to education is unequal, then higher education levels might incease income disparities [@rodriguez-pose2008]. The population density, our second variable, can explain inequality since regions with a higher population density might have different economic behaviours. Our last variable, rail network (infrastructure), can influence economic development and accessibility, which also can affect income inequality in a region [@chatterjee2012].

```{r}
#| echo: false
#| output: false
#| label: data acquistion

# Importing datasets

# Data for population density
demo_dens <- read_csv("Raw_data/demo_dens.gz")

# Data for education
educ_data <- read_csv("Raw_data/educ.gz")

# Data for rail network
rail_data <- read_csv("Raw_data/rail.gz")


# Renaming and tidying up the new dataframes 
demo_dens <- demo_dens %>%
  rename(year = TIME_PERIOD, id_nuts2 = geo, pop_density = OBS_VALUE)

educ_data <- educ_data %>%
  rename(year = TIME_PERIOD, id_nuts2 = geo, students_percentage = OBS_VALUE)

rail_data <- rail_data %>%
  rename(year = TIME_PERIOD, id_nuts2 = geo, rail_km = OBS_VALUE)
```

```{r}
#| echo: false
#| output: false

# The NUTS 2 regions in France changed names in 2018. The dataset with education use the old codes while the other datasets use the new codes, we therefore had to change the names in order to be able to merge them together properly. 

# Changing NUTS 2 names for France
nuts2_mapping <- c(
  FR10 = "FR10",
  FR21 = "FRF2",
  FR22 = "FR22",
  FR23 = "FRD2",
  FR24 = "FRC1",
  FR25 = "FRD2",
  FR26 = "FRF2",
  FR30 = "FR22",
  FR41 = "FRF3",
  FR42 = "FRF1",
  FR43 = "FRF3",
  FR51 = "FRG0",
  FR52 = "FRH0",
  FR53 = "FRI3",
  FR61 = "FRI3",
  FR62 = "FRJ2",
  FR63 = "FRI3",
  FR71 = "FRK2",
  FR72 = "FRK1",
  FR81 = "FRJ1",
  FR82 = "FRL0",
  FR83 = "FRM0"
  )

# Adding the new names to the dataset
educ_fixed <- educ_data |>
  mutate(id_nuts2 = recode(id_nuts2, !!!nuts2_mapping))

# Selecting only the necessary columns
demo_dens_selected <- select(demo_dens, year, id_nuts2, pop_density)
educ_selected <- select(educ_fixed, year, id_nuts2, students_percentage)
rail_selected <- select(rail_data, year, id_nuts2, rail_km)

# Merging the datasets
merged_datasets <- demo_dens_selected |>
  left_join(educ_selected, by = c("year", "id_nuts2")) |>
  left_join(rail_selected, by = c("year", "id_nuts2"))

# Filter by year 2010
merged_datasets_2010 <- merged_datasets |>
  filter(year == 2010)

# Merging with dataset containing GDP per capita and gini
Merged_datasets_gini <- merged_datasets_2010 |>
  left_join(data2010, by = c("year", "id_nuts2"))

# cleaning dataset and selecting variables
Merged_datasets_gini <- Merged_datasets_gini |>
  select(year, id_nuts2, id_nuts0, gini_n2, GDP_per_capita, log_GDP_per_capita, students_percentage, pop_density, rail_km)

# Removing NA values from gini_n2 
Merged_datasets_gini <- Merged_datasets_gini |>
  filter(!is.na(gini_n2))

# Remove nuts 2 variables that gets repetead
cleaned_data <- Merged_datasets_gini |>
  distinct(id_nuts2, .keep_all = TRUE)
```

### 2. Multiple Linear Regression Model

We will in this part do a Multiple Linear Regression model by using the variables education (in percentage of pupils and students in education, % of total population), population density and rail network in km. This model will tell us if these variables can help explain change in the gini coefficient.

In both our simple linear regression model, and now in our multiple linear regression model, we use the logarithmic function which makes it easier to linearize the relationship between the variables. By using it for GDP per capita, we can reflect changes more effectively. For rail network and population density, the logarithm function ensure that the model capture proportional changes and deals better with the wide range of values.

```{r}
#| echo: false
#| fig-cap: Multiple Linear Regression Model

# Estimations with the help of several independent variables

# To begin with, we'll look at how education can explain the gini coefficient
lm1 <- lm(gini_n2 ~ log_GDP_per_capita + students_percentage, subset(cleaned_data))

# Here we look at how both population density and education can explain the gini coefficient 

lmdens1 <- lm(gini_n2 ~ log_GDP_per_capita + students_percentage + log(pop_density), subset(cleaned_data))

# Lastly, we look at how all of our selected variables, rail, education and population density, can explain the gini coefficient

lm2 <- lm(gini_n2 ~ log_GDP_per_capita + students_percentage + log(pop_density) + log(rail_km), subset(cleaned_data))

# Regression statistics
huxreg("Model" = lm1, 
       "Model 2" = lmdens1, 
       "Model 3" = lm2, 
       statistics = c("r.squared","adj.r.squared", "statistic", "p.value"))
```

### 3. Model Interpretation

Our first model in the Multiple Linear Regression model examine how education in addition to GDP per capita can help explain the gini coefficient. The second model look at both education, GDP per capita, and population density, while the third model examine them all and also add rail network.

For model 1, the adjusted R-squared is 0.033, indicating that the model explains around 3% of the variability in the gini coefficient. Since this is relatively low, it suggests that model 1 is not suitable in explaining the variance in gini.

# Assignment 3: Alternative Functional Forms and Panel Estimates

## Part A: Testing Development Effects Across Subsets

### Subset Analysis:

To begin the third assignment, we will divide the data into different subsets. We have chosen to divide the countries based on size and population; we'll therefore have one subset with France, and one subset with the rest of the countries. We have several reasons for the dividing the countries like this:

1.  France is one of the largest countries in Europe, with a great economic and political influence. The larger size and population of France may lead to different economic dyamics compared to the other smaller countries.

2.  Larger countries might have a greater diversity of economic activities, wich affects the distribution of wealth and income differentely than in smaller countries with less diverse economies (source). We can see this by looking at how some of the NUTS 2 regions in France differ far more than in other countries.

3.  The size and population can influence public policy, like social welfare, which impacts income distribution and inequality (source).

4.  Larger countries often have larger internal markets, which can affect economic development and income distribution differently compared to smaller economies, where ecternal trade might be more crucial.

| Country  | Population (in million) | Size (km\^2) | NUTS 2 observations |
|----------|-------------------------|--------------|---------------------|
| France   | 67,75                   | 551 695      |                     |
| Denmark  | 5,85                    | 42 952       |                     |
| Slovakia | 5,4                     | 49 000       |                     |
| Hungary  | 9,71                    | 93 000       |                     |
| Portugal | 10,33                   | 92 000       |                     |

```{r}
#| echo: false
#| output: false

# Dataframe with just france
gini_nuts_2_FR <- gini_nuts_2 |> 
  filter(id_nuts0 == "FR", gini_n2 > 0)

# Dataframe with the other countries
gini_nuts_2_C <- gini_nuts_2 |> 
  filter(id_nuts0 != "FR", gini_n2 > 0)
```

```{r}
#| echo: false
#| output: false

# Descriptive analysis
summary(gini_nuts_2_FR)
summary(gini_nuts_2_C)
```

```{r}
#| echo: false

# Regression analysis
# France
lmFR <- lm(gini_n2 ~ log(GDP_per_capita), data = gini_nuts_2_FR)
# Others
lmC <- lm(gini_n2 ~ log(GDP_per_capita), data = gini_nuts_2_C)

huxreg(France = lmFR,
       Others = lmC,
       statistics = c("r.squared","adj.r.squared", "statistic", "p.value"))
```

```{r}
#| echo: false
#| output: false

# Comparative analysis
# Welch two sample t-test
t.test <- t.test(gini_nuts_2_FR$gini_n2, gini_nuts_2_C$gini_n2)
print(t.test)
```

### Subset Analysis Discussion:

In order to discuss the differences between the two subsets, we have done different analysis: descriptive, regression and comparative.

France has a mean gini coefficient of 0.06960, while the mean gini coefficient of the other countries is 0.062308. France has a slightly higher gini, meaning that they on average have a higher amount of economic inequality compared to the rest. The mean of GDP per capita is also higher in france (2.750 \> 1.743), suggesting that they also on average have a higher level of economic development (de har både høyere økonomisk ulikhet og økonomisk utvikling, hva er grunnen til dette? Kan se dette på regression analysis!! r quared har høy positiv korrelasjon).

Looking at the regression analysis of France, we can see that the intercept is -0.034 with a p-value that is lower than 0.001, suggesting that the intercept is different from zero. The coefficient for log of GDP per capita is 0.110 with a p-value lower than 0.001; meaning that as the log of GDP per capita increase, the gini coefficient increase significantly, which suggest that a higher GDP per capita also gives us greater income inequality. Laslty, the R-squared is 0.490, meaning that around 49% of the variance in the gini coefficient can be explained by GDP per capita. *This is a relatively high value,* and suggest a strong model fit.

## Part B: Exploring Alternative Functional Forms

### Functional Form Exploration:

```{r}

# Logarithmic model
log_model <- lm(gini_n2 ~ log(GDP_per_capita), data = gini_filtered)

# Quadratic model
quad_model <- lm(gini_n2 ~ GDP_per_capita + I(GDP_per_capita^2), data = gini_filtered)

# Cubic model
cubic_model <- lm(gini_n2 ~ GDP_per_capita + I(GDP_per_capita^2) + I(GDP_per_capita^3), data = gini_filtered)

# Check the summary of each model
summary(log_model)
```

```{r}
summary(quad_model)
```

```{r}
summary(cubic_model)
```

### 

### Estimation and Visualization:

```{r}
# Quadratic model

# Create a new data frame for plotting predicted values
plot_data <- data.frame(GDP_per_capita = seq(min(gini_filtered$GDP_per_capita), max(gini_filtered$GDP_per_capita), length.out = 250))
plot_data$gini_pred <- predict(quad_model, newdata = plot_data)

# Plotting
ggplot(gini_filtered, aes(x = GDP_per_capita, y = gini_n2)) +
  geom_point(alpha = 0.5) +  # Plot the actual data points
  geom_line(data = plot_data, aes(x = GDP_per_capita, y = gini_pred), color = 'blue') +  # Add the regression line
  labs(title = "Quadratic Model of GDP per Capita and Gini Coefficient",
       x = "GDP per Capita",
       y = "Gini Coefficient") +
  theme_minimal()
```

```{r}
# Logarithmic model

# Create a new data frame for plotting predicted values
plot_data <- data.frame(GDP_per_capita = seq(min(gini_filtered$GDP_per_capita), max(gini_filtered$GDP_per_capita), length.out = 250))
plot_data$gini_pred <- predict(log_model, newdata = plot_data)

# Plotting
ggplot(gini_filtered, aes(x = GDP_per_capita, y = gini_n2)) +
  geom_point(alpha = 0.5) +  # Plot the actual data points
  geom_line(data = plot_data, aes(x = GDP_per_capita, y = gini_pred), color = 'red') +  # Add the regression line
  scale_x_log10() +  # Logarithmic scale for the x-axis
  labs(title = "Logarithmic Model of GDP per Capita and Gini Coefficient",
       x = "GDP per Capita (log scale)",
       y = "Gini Coefficient") +
  theme_minimal()

```

```{r}


# Create a new data frame for plotting predicted values
plot_data <- data.frame(GDP_per_capita = seq(min(gini_filtered$GDP_per_capita), max(gini_filtered$GDP_per_capita), length.out = 250))
plot_data$gini_pred <- predict(cubic_model, newdata = plot_data)

# Plotting
ggplot(gini_filtered, aes(x = GDP_per_capita, y = gini_n2)) +
  geom_point(alpha = 0.5) +  # Plot the actual data points
  geom_line(data = plot_data, aes(x = GDP_per_capita, y = gini_pred), color = 'blue') +  # Add the regression line
  labs(title = "Cubic Model of GDP per Capita and Gini Coefficient",
       x = "GDP per Capita",
       y = "Gini Coefficient") +
  theme_minimal()

```

```{r}
# Calculate residuals
residuals_quad <- gini_filtered$gini_n2 - predict(quad_model, gini_filtered)
residuals_cubic <- gini_filtered$gini_n2 - predict(cubic_model, gini_filtered)
```

```{r}
# Create a dataframe for plotting residuals
residuals_data <- data.frame(GDP_per_capita = gini_filtered$GDP_per_capita, 
                             Residuals_Quad = residuals_quad, 
                             Residuals_Cubic = residuals_cubic)

# Plotting residuals
ggplot(residuals_data) +
  geom_line(aes(x = GDP_per_capita, y = Residuals_Quad, color = "Quadratic")) +
  geom_line(aes(x = GDP_per_capita, y = Residuals_Cubic, color = "Cubic")) +
  labs(title = "Comparison of Residuals",
       x = "GDP per Capita",
       y = "Residuals") +
  theme_minimal() +
  scale_color_manual(values = c("Quadratic" = "blue", "Cubic" = "red"))

```

```{r}
sd(residuals_quad)
sd(residuals_cubic)
mean(residuals_quad^2)
mean(residuals_cubic^2)
```

### Results Interpretation:

## Part C: Heteroskedasticity Testing and Causality Discussion

### Heteroskedasticity Testing:

```{r}
lm_01 <- lm(gini_n2 ~ GDP_per_capita, data = gini_filtered)
```

```{r}

# Obtain fitted values and residuals from the model
fitted_values <- fitted(lm_01)
residuals <- resid(lm_01)

# Create the plot
plot(fitted_values, residuals, 
     xlab = "Fitted Values", 
     ylab = "Residuals", 
     main = "Residuals vs Fitted Values for Linear Model",
     pch = 20)
abline(h = 0, col = "blue", lwd = 2) # Add a horizontal line at 0

```

```{r}

# Breusch-Pagan test for the original linear model
bptest_linear <- bptest(lm_01)

# Breusch-Pagan test for the logarithmic model
bptest_log <- bptest(log_model)

# Breusch-Pagan test for the quadratic model
bptest_quad <- bptest(quad_model)

# Output the test results
print(bptest_linear)
print(bptest_log)
print(bptest_quad)
```

The Breusch-Pagan test is used to detect heteroskedasticity in a regression model. The test works by checking if the variances of the errors from the regression are dependent on the values of the independent variables, which would violate one of the key assumptions of ordinary least squares (OLS) regression.

```{r}

# Calculate robust standard errors for the original linear model
coeftest_lm_01 <- coeftest(lm_01, vcov = vcovHC(lm_01, type = "HC"))

# Calculate robust standard errors for the logarithmic model
coeftest_log_model <- coeftest(log_model, vcov = vcovHC(log_model, type = "HC"))

# Calculate robust standard errors for the quadratic model
coeftest_quad_model <- coeftest(quad_model, vcov = vcovHC(quad_model, type = "HC"))

# Print out the results
print(coeftest_lm_01)
print(coeftest_log_model)
print(coeftest_quad_model)

```

### Causality Discussion:

## Part D: Panel Estimates

### Panel Estimation Task:

### Panel Estimation Analysis:

### Panel Estimation Discussion:
